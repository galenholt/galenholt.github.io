---
title: "R_py_package"
author: "Galen Holt"
---

I have a package that is mostly R, but needs to call some python functions. Those functions are themselves fairly lightweight wrappers of functions from another python package. So, the basic structure is that I have a package with the usual R package structure, and a python script in `inst/python/pyscript.py` that contains some function definitions.

There are two main issues I need to address here

1.  How to set the python environment for package dev and for the user
2.  How to expose the python functions for both dev and the user

Solving these was surprisingly quick for dev, using `devtools::load_all`-

## Works with load_all

I began dev with the following setup, and it just worked with `load_all`

### Environment

The python environment I'm using is in a separate directory in the same repo, so I can point to it by going up and over with `../pydirectory`

In `.Rprofile`, set `Sys.setenv(RETICULATE_PYTHON = '../pydir/.venv/Scripts/python.exe')`

I also followed instructions from [reticulate](https://rstudio.github.io/reticulate/articles/python_dependencies.html) to handle dependencies in the `.onLoad` function and `DESCRIPTION` file, but am pretty sure that doesn't come into play when I use `load_all`.

### Exposing functions

The `reticulate::source_python('pyfile.py')` function makes functions in `pyfile.py` directly callable. So I naively created `R/loadpys.R` that contains only this line, since everything in R gets read on package load: `reticulate::source_python(system.file("python/pyfile.py", package = 'packagename'))` .

### Breaking issues

When I try to actually install the package (or `check`, `build`, etc), I first got errors about not being able to find the python environment at `../pydir/.venv/Scripts/python.exe` .

When the package is built, I do not have access to the python functions. Presumably this is because `load_all` puts everything into memory, including private functions, but actually installing only gets the exported ones.

## Fixing environment path

Running `devtools::check` seems to have worked to just replace the relative path to the environment with a full path, e.g.

`Sys.setenv(RETICULATE_PYTHON = 'C:/Users/USER/Documents/REPO_DIR/pydir/.venv/Scripts/python.exe')`.

It's not clear to me how this will work for installing the package elsewhere (e.g. by a user, not from within the repo during dev). Obviously they'll need their own python env, and so will need to set that up. Will come back to that once I can actually get the package built with the functions.

## Exporting python functions

There are brief instructions at the [reticulate vignettes](https://rstudio.github.io/reticulate/articles/package.html) for wrapping python modules. Presumably this would work, but it's unclear how to call them, whether they would be exported, and whether they'd need to be called python-style with `module.function`, or just the bare names. It also conflicts with the advice in the [vignette about package dependencies](https://rstudio.github.io/reticulate/articles/python_dependencies.html) which seems to be more recent. It's not completely clear what still applies- clearly the ways of specifying environments has changed, but has the way to access functions changed as well? And how do we make them available to a user (and not just internally)?

### Write exported R wrappers

In `loadpys.R`, instead of just having `reticulate::source_python(system.file("python/pyfile.py", package = 'packagename'))` call, write an R wrapper for the functions we want to export. **NOTE** that we have to put the `source_python` *inside* the R function (it does not work to have it at the head of the file).

``` r
pyfun_R <- function(...) {
  reticulate::source_python(system.file("python/pyfile.py", 
                                        package = 'packagename'))
  pyfun(...)
}
```

That seems to work if we make sure there's a `@export` in the roxygen documentation. But it's not exactly pretty.

*Note*- it also works if we bring over the full arguments instead of dots, which would be better for documenting, probably. Guess it depends if we want to read R or python documentation.

*Note*- the following error happens when the `source_python` isn't in the function definition.

    Error in `(function (command = NULL, args = character(), error_on_status = TRUE, â€¦`:

## Can I use onLoad?

The [instructions from reticulate](https://rstudio.github.io/reticulate/articles/package.html) describe bringing in a module. I *think* that is ultimately how we should do things, but unclear how difficult.

### Back to load_all

To test, let's just see what we get when we `devtools::load_all()`

### Import module

The instructions above reference importing a module that is installed. We should be able to do that by making our python code a small package. But in the meantime, let's use `reticulate::import_from_path`.

Using `load_all`, `py_functions <<- reticulate::import_from_path("pyfile", path = "inst/python", delay_load = TRUE)` works. I get an object `py_functions` and can access the individual functions with `py_functions$func1` etc. *Note*- it also works to pass the path to the python directory `py_functions <<- reticulate::import_from_path("pyfile", path = "inst/python", delay_load = TRUE)`.

### Running

That runs after a `load_all` by calling `pyfile$pyfun(args)`. But does it still need to be exported in an R wrapper to actually use as a package? **YES**- building the package can't find the function.

And if we do it this way, are the python functions just floating around in the user's global environment? That would be bad. **NO**- they don't seem to be.

It *does* seem to fail when I try to run the vignette in a different directory after `devtools::install_github()`. So that implies the method really isn't working right. Why does it work for `load_all`?

### Another issue

The approach above seems to work, I can `devtools::install()`\` and run the package, using the exported R functions.

The catch is that `devtools::check()` hangs on building a vignette that uses those functions (even though I can run that same vignette after `devtools::install()`.

Is it that the python env gets called in one of them but not the other? setting `RETICULATE_PYTHON` in the vignette doesn't help.

Does it actually not work, and I'm just carrying around info to make it work somewhere? Nope, it doesn't work, after using `devtools::install_local` to install into a separate R session.

## Solution (for now)

Use `reticulate::source_python`, but with `envir = globalenv()`, which seems to accomplish what the `<<-` was doing with `reticulate::import` in `.onLoad`. And in fact we can do that in `.onLoad`. so my `.onLoad`now looks like

``` r
.onLoad <- function(libname, pkgname) {
  reticulate::configure_environment(pkgname)

  reticulate::source_python(system.file("python/controller_functions.py", 
                                        package = 'werptoolkitr'), 
                            envir = globalenv())

}
```

That *doesn't* allow the user to `library(package)` and then set up their python- they'll need to have python sorted ahead of time. Using the `delay_load = TRUE`in `reticulate::import`would be better, but it doesn't seem to work without a full py package.

### How to test (relatively) quickly in a clean session-

1.  Start a new Rproject

2.  Run `devtools::install_local("path/to/package", force = TRUE)` .

    1.  Without the `force = TRUE` this almost never rebuilds even with changes.

3.  Then `library(packagename)`

4.  `Sys.setenv(RETICULATE_PYTHON = 'path/to/venv')` (otherwise it will try to install conda and barf)

    1.  I would have thought I'd have to do this before the `library`, but it seems to work.

    2.  Better is to have a path to venv in `.Rprofile`, anyway

    3.  *NOTE* if the `.venv` *is* in the outer directory, I'm getting weird errors when I try to `Sys.setenv` or otherwise set the path to the venv (it's either prepending `~/virtualenvs` or `C::/` unless I pass a full fixed path. Seems to work in that case to just not set the environment variable though, and {reticulate} sorts it out correctly.

5.  Try to use the functions and see if they break.
