---
title: "Random effects with uneven groups"
format: html
---

```{r}
library(tidyverse)
library(withr)
library(glmmTMB)
library(patchwork)
devtools::load_all()
```

```{r}
# need consistent plot colors
mod_types <- c("cluster_rand_x", "cluster_fixed_x",
               "cluster_rand", "cluster_fixed",
               "cluster_raw", 'no_cluster') 
mod_pal <- make_pal(mod_types, palette = 'nationalparkcolors::Saguaro', refvals = 'cluster_rand_x', refcols = 'dodgerblue')

```

This is essentially preamble to understanding the beta-binomial issues we're having. But we should be able to do a better job sharpening our intuition of what we expect if we start off fully gaussian.

This builds on the [outline](beta_binomial_error_outline.qmd) I developed and the work Sarah did (students/Sarah_Taig/Random Effects Simulations) (though I think the emphasis will be different; we'll see), as well as some beta-binom errorbar checks in caddis/Testing/Error_bars.qmd.

I think I'll likely just do gaussian here. Then bb in a parallel doc. And likely will do a model comparison thing too- i.e. spaMM vs glmTMB vs lme4::glmer as in caddis/Analyses/Testing/df_z_t_for_sarah/ (and add {brms}).

And will likely need to incorporate some assessments of the se being calculated at various scales, as explored in caddis/Analyses/Testing/Error_bars.qmd.

We'll need to bring in real data at some point, but I think not in this doc (hence why it's here, and some of the other testing is in caddis.

I think We'll want to do some actual math here somewhere too, to show exactly how the random coefficients relate to the estimates of the fit and the clusters. 

Are we just recapitulating [this](https://m-clark.github.io/posts/2019-05-14-shrinkage-in-mixed-models/)? Kind of. Slightly different emphasis and we'll end up taking it further, but should be careful.

The data generation function lets us have random slopes. These are super relevant in some cases, e.g. following people or riffles through time, where observations might have different x-values within the cluster. I *think* I'll largely ignore them here, because the situation we're trying to address doesn't (each cluster has a single x), and so the in-cluster slopes are irrelevant. They could certainly be dealt with in this general exploration, but it would just make everything factorially complicated.

# random and residual sd and fits

Before we do anything with unbalanced clusters, let's first just see how the random and residual sd alters the way fits work. More importantly, let's establish some approaches to seeing how the random structure affects the outcome.

-   fits through points
-   fits through clusters
-   full model fit
-   cluster error bars on the clusters, i.e. from a fixed model of the clusters
-   cluster error bars from the random model. What *is* this? the random sd will be the error of each around the *line*, then residual will be within-cluster. Can I extract and plot that? I think that will actually be key to understanding what's happening.

*all* of this from model fits.

```{r}

xrange = c(0, 10)
# we'll want this for predicting the fits
xdata <- tibble(x = seq(from = min(xrange), to = max(xrange), by = diff(xrange)/100))

with_seed(11,
          sdparams <- expand_grid(
            N = 50, 
            n_clusters = 10,
            cluster_N = 'even',
            intercept = 1, 
            slope = 0.5,
            sigma = c(0.1, 1),
            sd_rand_intercept = c(0.5, 2),
            sd_rand_slope = 0, 
            rand_si_cor = 0,
            # putting this in a list lets me send in vectors that are all the same
            cluster_x = list(runif(n_clusters,
                                   min = min(xrange), max = max(xrange))),
            obs_x_sd = 0
          )
)

# There's got to be a way to pmap straight into a mutate without having to send the dataframe in again.
with_seed(11, 
          sddata <- sdparams |>
            purrr::pmap(simulate_gaussian_mm) |> 
            tibble(simdata = _) |> 
            bind_cols(sdparams)
)
```

## Fit models and make figures

Probably end up moving this to a function rather than copy-paste for each section

```{r}
# Get the full models
sddata <- sddata |>
  mutate(full_models = map(simdata, \(x) make_fullmodels(x)))
```


```{r}
# Get the cluster estimates as directly as possible
sddata <- sddata |> 
  mutate(cluster_estimates = map2(full_models, simdata,
                                  \(x,y) estimate_clusters(x, y)))
```

```{r}
# Get the predictions at each cluster and corresponding x
sddata <- sddata |> 
  mutate(cluster_predictions = map2(full_models, simdata,
                                    \(x,y) predict_clusters(x, y)))
```

```{r}
# Get the lines through the cluster estimates- what our eyes will try to draw if we plot the cluster points
sddata <- sddata |> 
  mutate(cluster_models = map(cluster_estimates,
                                    \(x) model_from_clusters(x)))
```

```{r}
# Fit the actual model fits for the x range for the full models and the fits through cluster estimate models
# the warnings here are important but are about the estimation; nothing is broken with the code here.
sddata <- sddata |> 
  mutate(fitted_x_lines = map(full_models,
                              \(x) fit_x_full(x, xvals = xdata)),
         fitted_x_lines_tocluster = map(cluster_models, 
                                        \(x) fit_x_cluster(x, xvals = xdata)))
```

```{r}
# Get the cluster residuals so we can see shrinkage.
sddata <- sddata |> 
  mutate(cluster_deviations = pmap(sddata, get_cluster_residuals))
```

## Make figures

```{r}
# Need this
sddata <- sddata |> 
  mutate(mod_pal = list(mod_pal))
```

```{r}
# THe main fig we actually want
sddata <- sddata |> 
  mutate(fit_with_clusters = pmap(sddata, make_fit_figure))
```

```{r}
# The most relevant diagnostic- the fit of and cluster estimates compared to a naive fit without clusters and direct estimation of cluster values
sddata <- sddata |> 
  mutate(method_comparison = pmap(sddata, make_fit_vs_naive))
```

```{r}
# Shrinkage
sddata <- sddata |> 
  mutate(shrink = map2(cluster_deviations, mod_pal, 
                       \(x,y) make_shrinkage(x, y)))
```

These are more for testing and reference

```{r}
# more complete cluster estimate comparison
sddata <- sddata |> 
  mutate(cluster_compare = pmap(sddata, compare_cluster_estimates))
```

```{r}
# compare the to-cluster-estimate fits to teh full fits
sddata <- sddata |> 
  mutate(fit_data_v_clusters = pmap(sddata, compare_cluster_to_full))
```

Now we're gettng fairly esoteric
```{r}
# Compare the estimates for the cluster with what we get from 'predict' on the models
# and the impact of including x on cluster estimates.
sddata <- sddata |> 
  mutate(cluster_est_to_pred = pmap(sddata, compare_cluster_est_to_pred)) |> 
  mutate(cluster_x_effect = pmap(sddata, compare_effect_of_x)) |> 
  mutate(cluster_sep_v_fixed = pmap(sddata, compare_sep_to_fixed))

```

```{r}
# these will help us see what's going on with our current method, but might need to be updated once we have nesting.
sddata <- sddata |> 
  mutate(current_method = pmap(sddata, make_current_plot)) |> 
  mutate(method_comparison_all = pmap(sddata, make_full_method_comparison))
```

```{r}
sddata |> 
  unnest(cols = simdata) |> 
ggplot(aes(x = x, y = y, color = factor(cluster))) + 
  geom_point() +
  facet_grid(sigma ~ sd_rand_intercept)
```

Do I want to figure out the facetting? Not really, not until I know what I want to compare. I will want to label the figs somehow though if I just patchwork them.

## Results

So, for the 2x2 matrix we have here with different random and residual variance.

```{r}
wrap_plots(sddata$fit_with_clusters)
```
```{r}
wrap_plots(sddata$method_comparison) +
  plot_layout(guides = 'collect')
```
```{r}
wrap_plots(sddata$shrink) +
  plot_layout(guides = 'collect')
```
## Next

Now, the question is, what happens if the clusters are uneven?
And what if that is structured?
Time to update the simulation model
