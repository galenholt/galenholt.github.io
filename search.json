[
  {
    "objectID": "data_acquisition/bom_water.html",
    "href": "data_acquisition/bom_water.html",
    "title": "Waterdata from BOM",
    "section": "",
    "text": "I wrote {hydrogauge} to get information about water gauges in Victoria, and then discovered it also works in NSW and Queensland. It does not seem to work in South Australia though.\nCan we just use bomWater? Or use it to figure out how to call BOM myself?\nFirst question is whether it works. I’ve heard rumors BOM has gotten harder to call, but mdba-gauge-getter still manages.\nrenv::install('buzacott/bomWater')\nlibrary(bomWater)\nIt doesn’t obviously have a lot of the query tools from hydrogauge, but let’s see if it works with the example\ncotter_river &lt;- get_daily(parameter_type = 'Water Course Discharge',\n                          station_number = '410730',\n                          start_date     = '2020-01-01',\n                          end_date       = '2020-01-31')\nSeems to. Let’s try a couple I know I need\nmr97 &lt;- get_daily(parameter_type = 'Water Course Discharge',\n                  station_number = 'A4260505',\n                  start_date = '2000-01-01',\n                  end_date = '2000-05-30')\nThat basically looks like it works. It’s missing some functionality I want, but much better than nothing.\nget_station_list(station_number = 'A4260505')\n\n# A tibble: 1 × 5\n  station_name          station_no station_id station_latitude station_longitude\n  &lt;chr&gt;                 &lt;chr&gt;           &lt;int&gt;            &lt;dbl&gt;             &lt;dbl&gt;\n1 River Murray at Lock… A4260505      1617110            -34.2              142.\nget_parameter_list(station_number = 'A4260505')\n\n# A tibble: 2 × 7\n  station_no station_id station_name         parametertype_id parametertype_name\n  &lt;chr&gt;           &lt;int&gt; &lt;chr&gt;                           &lt;int&gt; &lt;chr&gt;             \n1 A4260505      1617110 River Murray at Loc…            11762 Water Course Disc…\n2 A4260505      1617110 River Murray at Loc…            11763 Water Course Level\n# ℹ 2 more variables: parametertype_unitname &lt;chr&gt;,\n#   parametertype_shortunitname &lt;chr&gt;\nIt looks like there is a getDataAvailabiltiy option in the API, but bomWater doesn’t query it. The requests in bomWater don’t obviously map to the docs, so this would take some tweaking.\nIn searching for how the ‘request’ in bomWater turns into the getSomethingSomething in the API (unsuccessfully), I found another package to try. It’s canadian, but seems to hit Kisters WISKI generally.\nlibrary('kiwisR')\nCheck it works.\nki_timeseries_list(hub = 'https://www.swmc.mnr.gov.on.ca/KiWIS/KiWIS?', station_id = '144659')\n\n# A tibble: 223 × 6\n   station_name station_id ts_id ts_name from                to                 \n   &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;   &lt;dttm&gt;              &lt;dttm&gt;             \n 1 Jackson Cre… 144659     9489… Precip… 2007-06-18 20:15:00 2024-09-10 22:15:00\n 2 Jackson Cre… 144659     1143… Precip… 2007-07-01 05:00:00 2020-09-01 05:00:00\n 3 Jackson Cre… 144659     1143… Precip… 2007-06-18 05:00:00 2024-09-11 05:00:00\n 4 Jackson Cre… 144659     9489… TAir.1… 2007-06-18 20:15:00 2024-09-10 22:15:00\n 5 Jackson Cre… 144659     9489… TAir.D… 2007-06-18 05:00:00 2024-09-09 05:00:00\n 6 Jackson Cre… 144659     9489… TAir.D… 2007-06-18 05:00:00 2024-09-09 05:00:00\n 7 Jackson Cre… 144659     1129… TAir.6… 2007-06-19 00:00:00 2024-09-10 18:00:00\n 8 Jackson Cre… 144659     1326… TAir.D… 2007-06-18 05:00:00 2024-09-11 05:00:00\n 9 Jackson Cre… 144659     1326… TAir.D… 2007-06-18 05:00:00 2024-09-11 05:00:00\n10 Jackson Cre… 144659     9490… TWater… 2007-06-18 05:00:00 2024-09-09 05:00:00\n# ℹ 213 more rows\nDoes it work for BOM? No, the url is almost certainly wrong. This expects a KiWIS API, which it looks like BoM doesnt use (at least just shoving Kiwis on the end doesn’t work.\nki_timeseries_list(hub = \"http://www.bom.gov.au/waterdata/services\", station_id = 'A4260505')\n\nError in if (nrow(json_content) == 2) {: argument is of length zero\n\nki_timeseries_list(hub = \"http://www.bom.gov.au/waterdata/services/KiWIS/KiWIS?\", station_id = 'A4260505')\n\nError: lexical error: invalid char in json text.\n                                       &lt;html&gt;&lt;head&gt;&lt;title&gt;Apache Tomca\n                     (right here) ------^\nInteresting. If I go to http://www.bom.gov.au/waterdata/services, I get the message “KISTERS KiWIS QueryServices - add parameter ‘request’ to execute a query.” So it is a KiWIS, but maybe doesn’t take request in the same way as kiwisR expects? bomWater does use request, so maybe this will help figure out how to specify new ones. Looking at code, kiwisR and bomWater look like they’re constructing the requests the same, so it’s a bit odd the kiwis doesn’t work with the bomWater url.\nAm I just calling something incorrectly? Can kiwisR hit that URL for other things? I can get a list of all stations. So that implies the URL does work. This is just very long, so I’m not rendering it.\nki_station_list(hub = \"http://www.bom.gov.au/waterdata/services\")\nIt doesn’t seem to work to search for stations by id though.\nki_station_list(hub = \"http://www.bom.gov.au/waterdata/services\", search_term = \"A4260505\")\n\n# A tibble: 0 × 5\n# ℹ 5 variables: station_name &lt;chr&gt;, station_no &lt;chr&gt;, station_id &lt;chr&gt;,\n#   station_latitude &lt;dbl&gt;, station_longitude &lt;dbl&gt;\nAh! It hits the station_name, not the gauge number in station_no\nki_station_list(hub = \"http://www.bom.gov.au/waterdata/services\", search_term = \"A*\")\n\n# A tibble: 1,951 × 5\n   station_name station_no station_id station_latitude station_longitude\n   &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt;                 &lt;dbl&gt;             &lt;dbl&gt;\n 1 A            61700620   400630                -30.3              115.\n 2 A            60210202   11517225              -35.1              118.\n 3 A            60210203   11517229              -35.1              118.\n 4 A            60210201   11517221              -35.1              118.\n 5 A            60210298   11520185              -35.1              118.\n 6 A            61311025   11457669              -32.7              116.\n 7 A            120310078  11287358              -25.5              129.\n 8 A            60110485   11465949              -33.7              121.\n 9 A            60110497   11465977              -33.7              121.\n10 A            60110584   11466057              -33.6              122.\n# ℹ 1,941 more rows\nSo, can I get it with\nki_station_list(hub = \"http://www.bom.gov.au/waterdata/services\",\n                search_term = \"River Murray at Lock 9 Downstream*\")\n\n# A tibble: 1 × 5\n  station_name          station_no station_id station_latitude station_longitude\n  &lt;chr&gt;                 &lt;chr&gt;      &lt;chr&gt;                 &lt;dbl&gt;             &lt;dbl&gt;\n1 River Murray at Lock… A4260505   1617110               -34.2              142.\nThe ki_timeseries_list uses station_id. But I’ve been feeding it gauge numbers, which are station_no. It works with the ID.\ntl &lt;- ki_timeseries_list(hub = \"http://www.bom.gov.au/waterdata/services\", station_id = '1617110')\n\ntl\n\n# A tibble: 55 × 6\n   station_name station_id ts_id ts_name from                to                 \n   &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;   &lt;dttm&gt;              &lt;dttm&gt;             \n 1 River Murra… 1617110    2086… Receiv… NA                  NA                 \n 2 River Murra… 1617110    2086… Harmon… NA                  NA                 \n 3 River Murra… 1617110    2086… DMQaQc… 1949-07-01 23:29:59 2024-09-08 22:30:01\n 4 River Murra… 1617110    2086… DMQaQc… 2008-11-26 04:34:59 2024-09-09 22:15:01\n 5 River Murra… 1617110    2086… DMQaQc… 2008-11-26 03:30:00 2024-09-09 21:30:00\n 6 River Murra… 1617110    3293… Derive… NA                  NA                 \n 7 River Murra… 1617110    3293… PR01Ma… NA                  NA                 \n 8 River Murra… 1617110    3293… PR01Ma… NA                  NA                 \n 9 River Murra… 1617110    3293… PR01Qa… 1949-07-01 23:29:59 2024-09-08 22:30:01\n10 River Murra… 1617110    3293… PR01Qa… 1949-07-01 23:29:59 2024-09-08 22:30:01\n# ℹ 45 more rows\nThen, I should be able to use ki_timeseries_values if I know the ts_id I want.There’s lots of cryptic ts_name in there, but daily is “DMQaQc.Merged.DailyMean.24HR”. There are two versions here, for different date ranges.\ntl[tl$ts_name == \"DMQaQc.Merged.DailyMean.24HR\", ]\n\n# A tibble: 2 × 6\n  station_name  station_id ts_id ts_name from                to                 \n  &lt;chr&gt;         &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;   &lt;dttm&gt;              &lt;dttm&gt;             \n1 River Murray… 1617110    2086… DMQaQc… 2008-11-25 14:30:00 2024-09-09 14:30:00\n2 River Murray… 1617110    2086… DMQaQc… 1949-07-01 14:30:00 2024-09-08 14:30:00\nIs that why ki_timeseries_values doesn’t have a station argument? are the ts_ids unique across gauges? Look at two gauges. COtter river (from way above) is id 13360.\nNo idea why Cotter has so many ts_ids with identical ranges, but they are unique.\ntl2 &lt;- ki_timeseries_list(hub = \"http://www.bom.gov.au/waterdata/services\", \n                         station_id = c('1617110', '13360'))\ntl2 |&gt; \n  dplyr::filter(ts_name == \"DMQaQc.Merged.DailyMean.24HR\")\n\n# A tibble: 8 × 6\n  station_name  station_id ts_id ts_name from                to                 \n  &lt;chr&gt;         &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;   &lt;dttm&gt;              &lt;dttm&gt;             \n1 River Murray… 1617110    2086… DMQaQc… 2008-11-25 14:30:00 2024-09-09 14:30:00\n2 River Murray… 1617110    2086… DMQaQc… 1949-07-01 14:30:00 2024-09-08 14:30:00\n3 Cotter R. at… 13360      1573… DMQaQc… 1963-07-02 14:00:00 2024-09-08 14:00:00\n4 Cotter R. at… 13360      1598… DMQaQc… 1963-07-02 14:00:00 2024-09-09 14:00:00\n5 Cotter R. at… 13360      3801… DMQaQc… 2003-02-23 14:00:00 2024-09-09 14:00:00\n6 Cotter R. at… 13360      3801… DMQaQc… 2003-02-23 14:00:00 2024-09-09 14:00:00\n7 Cotter R. at… 13360      3801… DMQaQc… 2003-02-23 14:00:00 2024-09-08 14:00:00\n8 Cotter R. at… 13360      3801… DMQaQc… 1999-09-23 14:00:00 2024-09-09 14:00:00\nbomWater must be dealing with duplication somehow, because\nany(duplicated(cotter_river$Timestamp))\n\n[1] FALSE\nah. bomwater just uses ts_id[1]. That’s likely not the best move. What’s better? not sure. Would be good to assess them somehow. Could give options of ‘longest’, ‘all’, ‘first’ (with longest possibly still needing a ‘first’ or ‘all’ if there are multiple.)\nSo, all that boils down to that I should be able to choose one of those ts_ids and pull data. Choosing one from the Murray and one from Cotter\ntest_timeseries &lt;- ki_timeseries_values(hub = \"http://www.bom.gov.au/waterdata/services\",\n                                        ts_id = c(\"208669010\", \"380185010\"), \n                                        start_date = '2010-01-01', end_date = '2010-02-28')\nlibrary(ggplot2)\nggplot(test_timeseries, aes(x = Timestamp, y = Value, color = station_name)) +\n  geom_line()\n\nWarning: Removed 6 rows containing missing values or values outside the scale range\n(`geom_line()`)."
  },
  {
    "objectID": "data_acquisition/bom_water.html#fitting-into-a-workflow",
    "href": "data_acquisition/bom_water.html#fitting-into-a-workflow",
    "title": "Waterdata from BOM",
    "section": "Fitting into a workflow",
    "text": "Fitting into a workflow\nI typically have a gauge number, want to get the period of record, and then pull data. I can do that here, but it’s a bit roundabout because the filters keep changing what they filter. And I’d like to not have to depend on both bomWater and kiwisR.\nAbove, I had to go from all stations, find the name and id that matched the no, and then could get the other things. But there’s got to be a way to just search with any of those, rather than different ones for different functions, right? bomWater seems to do it.\nIs there a way to search for the gauge? Not obviously, weirdly.\nSo, as it stands, a kiwisR based workflow looks something like this:\nGet the cross-referencing info for the gauges\n\ngauge_numbers &lt;- c('410730', 'A4260505')\n\nall_stations &lt;- ki_station_list(hub = \"http://www.bom.gov.au/waterdata/services\")\n\nintended_stations &lt;- all_stations |&gt; \n  dplyr::filter(station_no %in% gauge_numbers)\n\nIf we want to see what info is available (including date ranges)\n\navailable_info &lt;- ki_timeseries_list(hub = \"http://www.bom.gov.au/waterdata/services\",\n                                     station_id = intended_stations$station_id)\n\nIf we want to get the info, choose a var, but then we also need a ts_id.\n\nvar_to_get &lt;- \"DMQaQc.Merged.DailyMean.24HR\"\nstart_time &lt;- \"2010-01-01\"\nend_time &lt;- \"2010-02-28\"\nchoose_ids &lt;- 'first'\n\nall_var_to_get &lt;- available_info |&gt; \n  dplyr::filter(ts_name == var_to_get)\n\nif (choose_ids == 'first') {\n  ids_to_get &lt;- all_var_to_get |&gt; \n    dplyr::group_by(station_id) |&gt; \n    dplyr::summarise(ts_id = dplyr::first(ts_id),\n                     from = dplyr::first(from), \n                     to = dplyr::first(to)) # not sure worth returning\n}\n\nids &lt;- ids_to_get$ts_id\n\n\npulled_ts &lt;- ki_timeseries_values(hub = \"http://www.bom.gov.au/waterdata/services\",\n                                        ts_id = ids, \n                                        start_date = start_time, end_date = end_time)\n\nThat works. And then we’d likely want to conver to ML/d instead of cm^3s-1\n\nggplot(pulled_ts, aes(x = Timestamp, y = Value, color = station_name)) +\n  geom_line()\n\n\n\n\n\n\n\n\nSo, that is roundabout, but works. I guess I’ll do that until it gets too slow to pull the whole thing and then fork and add code."
  },
  {
    "objectID": "data_acquisition/bom_water.html#some-checking-of-the-available-sites",
    "href": "data_acquisition/bom_water.html#some-checking-of-the-available-sites",
    "title": "Waterdata from BOM",
    "section": "Some checking of the available sites",
    "text": "Some checking of the available sites\nWhat are the groups?\n\nki_group_list(hub = \"http://www.bom.gov.au/waterdata/services\")\n\n# A tibble: 8 × 3\n  group_id group_name             group_type\n  &lt;chr&gt;    &lt;chr&gt;                  &lt;chr&gt;     \n1 20017539 MDB_WIP_Storages       station   \n2 20017550 MDB_WIP_Watercourse    station   \n3 19792386 Rainfall daily 24      timeseries\n4 19792387 Rainfall monthly       timeseries\n5 19792388 Rainfall yearly        timeseries\n6 19792389 Rainfall daily 9       timeseries\n7 20017540 TS_MDB_WIP_Storages    timeseries\n8 20017541 TS_MDB_WIP_Watercourse timeseries\n\n\nWhy are those all prefaced by MDB? Shouldn’t this be australia-wide?\n\nall_watercourse_stations &lt;- ki_station_list(hub = \"http://www.bom.gov.au/waterdata/services\",\n                                            group_id = '20017550')\n\n\nlibrary(sf)\n\nLinking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.3.1; sf_use_s2() is TRUE\n\nall_ws &lt;- all_watercourse_stations |&gt; \n  st_as_sf(coords = c('station_longitude', 'station_latitude'))\n\nThat is quite obviously just the Murray-Darling Basin. Where are the rest of the BOM sites?\n\nggplot(all_ws) + geom_sf()\n\n\n\n\n\n\n\n\n\nall_stations &lt;- ki_station_list(hub = \"http://www.bom.gov.au/waterdata/services\")\n\nThere’s a lot of NA in there, so delete them and make sf\n\nall_s &lt;- all_stations |&gt; \n  dplyr::filter(!is.na(station_longitude) & !is.na(station_latitude)) |&gt; \n  st_as_sf(coords = c('station_longitude', 'station_latitude'))\n\nClearly nationwide. Plus some that are clearly wrong. Some I’m sure are boreholes and such, but there must be flow gauges that just don’t end up in any group_id.\n\nggplot(all_s) + geom_sf()\n\n\n\n\n\n\n\n\nTo confirm, look for a river definitely not in the MDB- the Gordon (at least some of these around -42 latitude) are in Tassie.\n\nki_station_list(hub = \"http://www.bom.gov.au/waterdata/services\",\n                search_term = \"Gordon*\")\n\n# A tibble: 29 × 5\n   station_name         station_no station_id station_latitude station_longitude\n   &lt;chr&gt;                &lt;chr&gt;      &lt;chr&gt;                 &lt;dbl&gt;             &lt;dbl&gt;\n 1 GORDON BK@FINEFLOWER 204067     586091                -29.4              153.\n 2 GORDON LAKE - AT IN… 646.1      3162538               -42.7              146.\n 3 GORDON RIVER - A/B … 187.1      3295551               -42.6              146.\n 4 GORDON RIVER - ABOV… 2491.1     3297416               -42.7              146.\n 5 Gordon               61310704   11447065              -33.0              116.\n 6 Gordon               509568     383787                -32.6              116.\n 7 Gordon Bore Rainfall 570823     14015                 -35.5              149.\n 8 Gordon Catchment     614060     392486                -32.6              116.\n 9 Gordon Clim17M Tower 509582     383835                -32.6              116.\n10 Gordon Clim33 Tower  509581     383828                -32.6              116.\n# ℹ 19 more rows"
  },
  {
    "objectID": "data_acquisition/bom_water.html#add-to-vicwate",
    "href": "data_acquisition/bom_water.html#add-to-vicwate",
    "title": "Waterdata from BOM",
    "section": "Add to vicwate?",
    "text": "Add to vicwate?\nCan I get this to work?\nI’m having issues with the requests, seemingly because I’m using httr2 instead of httr\nFor example, if i handbuild the call to the API for getStationList from kiwisR,\n\napi_url &lt;- \"http://www.bom.gov.au/waterdata/services\"\n\nreturn_fields &lt;- \"station_name,station_no,station_id,station_latitude,station_longitude\"\n\nsearch_term &lt;- \"River Murray at Lock*\"\n\n# Query\n  api_query &lt;- list(\n    service = \"kisters\",\n    datasource = 0,\n    type = \"queryServices\",\n    request = \"getStationList\",\n    format = \"json\",\n    kvp = \"true\",\n    returnfields = paste(\n      return_fields,\n      collapse = \",\"\n    )\n  )\n  \n  api_query[[\"station_name\"]] &lt;- search_term\n\nRun with httr::GET, as they do\n\nraw &lt;- httr::GET(\n        url = api_url,\n        query = api_query,\n        httr::timeout(15)\n      )\n\nraw\n\nResponse [http://www.bom.gov.au/waterdata/services?service=kisters&datasource=0&type=queryServices&request=getStationList&format=json&kvp=true&returnfields=station_name%2Cstation_no%2Cstation_id%2Cstation_latitude%2Cstation_longitude&station_name=River%20Murray%20at%20Lock%2A]\n  Date: 2024-09-10 23:24\n  Status: 200\n  Content-Type: application/json;charset=UTF-8\n  Size: 1.95 kB\n\n\nParse\n\nraw_content &lt;- httr::content(raw, \"text\")\n\n  # Parse text\n  json_content &lt;- jsonlite::fromJSON(raw_content)\n  \n    # Convert to tibble\n  content_dat &lt;- tibble::as_tibble(\n    x = json_content,\n    .name_repair = \"minimal\"\n  )[-1, ]\n\nBut if I use httr2, it doesn’t return anything in the body\n\n  response_body &lt;- httr2::request(api_url) |&gt;\n    httr2::req_body_json(api_query) |&gt;\n    httr2::req_perform()\n\n# Cannot retrieve empty body\n response_body &lt;- response_body |&gt;\n    httr2::resp_body_json(check_type = FALSE)\n\nError in `resp_body_raw()`:\n! Can't retrieve empty body.\n\n\nI think the issue is that the request format actually shouldn’t be json– this doesn’t look like what HTTR says its request looks like\n\n  httr2::request(api_url) |&gt;\n    httr2::req_body_json(api_query) |&gt;\n    httr2::req_dry_run()\n\nPOST /waterdata/services HTTP/1.1\nHost: www.bom.gov.au\nUser-Agent: httr2/1.0.3 r-curl/5.2.2 libcurl/8.3.0\nAccept: */*\nAccept-Encoding: deflate, gzip\nContent-Type: application/json\nContent-Length: 241\n\n{\"service\":\"kisters\",\"datasource\":0,\"type\":\"queryServices\",\"request\":\"getStationList\",\"format\":\"json\",\"kvp\":\"true\",\"returnfields\":\"station_name,station_no,station_id,station_latitude,station_longitude\",\"station_name\":\"River Murray at Lock*\"}\n\n\nIs it that i need to just use headers? instead of a json body?\n\n  httr2::request(api_url) |&gt;\n    httr2::req_headers(!!!api_query) |&gt;\n    httr2::req_dry_run()\n\nGET /waterdata/services HTTP/1.1\nHost: www.bom.gov.au\nUser-Agent: httr2/1.0.3 r-curl/5.2.2 libcurl/8.3.0\nAccept: */*\nAccept-Encoding: deflate, gzip\nservice: kisters\ndatasource: 0\ntype: queryServices\nrequest: getStationList\nformat: json\nkvp: true\nreturnfields: station_name,station_no,station_id,station_latitude,station_longitude\nstation_name: River Murray at Lock*\n\n\n\ntest_resp &lt;-   httr2::request(api_url) |&gt;\n    httr2::req_headers(!!!api_query) |&gt;\n    httr2::req_perform()\n\nLooks like that didn’t work…\n\nhttr2::resp_body_string(test_resp)\n\n[1] \"KISTERS KiWIS QueryServices - add parameter 'request' to execute a query.\"\n\n\nHow about req_url_query? That looks right\n\n  httr2::request(api_url) |&gt;\n    httr2::req_url_query(!!!api_query) |&gt;\n    httr2::req_dry_run()\n\nGET /waterdata/services?service=kisters&datasource=0&type=queryServices&request=getStationList&format=json&kvp=true&returnfields=station_name%2Cstation_no%2Cstation_id%2Cstation_latitude%2Cstation_longitude&station_name=River%20Murray%20at%20Lock%2A HTTP/1.1\nHost: www.bom.gov.au\nUser-Agent: httr2/1.0.3 r-curl/5.2.2 libcurl/8.3.0\nAccept: */*\nAccept-Encoding: deflate, gzip\n\n\n\ntest_out &lt;-  httr2::request(api_url) |&gt;\n    httr2::req_url_query(!!!api_query) |&gt;\n    httr2::req_perform()\n\n\njsonout &lt;- httr2::resp_body_json(test_out)\n\n# after some flipping and checking;\ntibnames &lt;- unlist(jsonout[1])\n\ntibout &lt;- jsonout[-1] |&gt; \n  tibble::tibble() |&gt; \n  tidyr::unnest_wider(col = 1, names_sep = '_') |&gt; \n  setNames(tibnames)\n\nThat seems to work. So, do I want to integrate this with hydrogauge? Can I use the same basic code? Not really, since the states need json bodies, and this needs a list-query. BUT, can I do some background parsing? If it works to send NULL in for the query and the body, can write the request to do both, but only actually do one or the other.\nDoes it work to do this?\n\ntest_out_bom &lt;-  httr2::request(api_url) |&gt;\n    httr2::req_url_query(!!!api_query) |&gt;\n  httr2::req_body_json(NULL) |&gt; \n    httr2::req_perform()\n\nparamlist &lt;- list(\"function\" = 'get_variable_list',\n                     \"version\" = \"1\",\n                     \"params\" = list(\"site_list\" = '233217',\n                                     \"datasource\" = \"A\"))\n# The query requires somethign named.\ntest_out_state &lt;- httr2::request(\"https://data.water.vic.gov.au/cgi/webservice.exe?\") |&gt;\n    httr2::req_url_query(fake = NULL) |&gt;\n  httr2::req_body_json(paramlist) |&gt; \n    httr2::req_perform()\n\n# it can be a list of null\nnullist &lt;- list(fake = NULL)\ntest_out_state &lt;- httr2::request(\"https://data.water.vic.gov.au/cgi/webservice.exe?\") |&gt;\n    httr2::req_url_query(!!!nullist) |&gt;\n  httr2::req_body_json(paramlist) |&gt; \n    httr2::req_perform()\n\nThat leaves aside the question of do we want to do that. It would be nice to unify the experience, I think, if that’s all we have to change in the main getResponse function. And then I can write separate bom and state versions of the functions accessible separately or through common wrappers that standardize syntax and outputs. Potentially just get_ts_traces_2."
  }
]